---
layout: post
date: 2019-12-12
title: 忍者秘籍 读书笔记 -1
tags: [JavaScript]
---

今天是双十二啊，要不是老师今天下午上课我估计这本书可能要到明年才能看，既然看了就打一下笔记好了。

---

# 第二章 运行时的页面的构建过程

## 2.1 生命周期

生命周期从用户在浏览器地址栏输入一串URL或单击一个链接开始
执行步骤：
- 页面的构建 创建用户界面
- 事件处理 进入循环，从而等待事件的发生，发生后调用事件处理器

应用的生命周期从用户关掉或离开页面而结束。


## 2.2 页面构建阶段
当页面能被展示或交互之前，其原理必须根据服务器获取的响应（通常是HTNL,CSS,JS代码）来构建，页面和构建阶段的目标是建立web应用的UI，有两个步骤：
- 解析HTML代码并构建文档对象类型
- 执行js 代码

步骤1会在浏览器处理HTML节点的过程中执行，步骤二会在HTML解析到脚本节点时执行，在页面构建过程中，两个步骤会交替执行

尽管DOM是根据HTNL来创建的，两者紧密联系，但两者并不相同，可以把HTML代码看做浏览器页面UI构建初始DOM的蓝图，为了正确构建每个DOM，浏览器会修复它在蓝图中发现的问题。

举个例子：如果你在head标签中使用了paragraph元素，head元素一般用途是提示页面的总体信息，例如页面标题字符编码，外部样式脚本，而不是用于类似本例中的定义页面内容，这里出现了错误，浏览器会静默修复错误，将段落元素放入了body中，构造了正确的DOM

### 2.2.2 执行js代码

包含在脚本元素中的JS代码由浏览器的js引擎执行，例如fireFox的Spidermonkey引擎，Chrome和Opera和V8引擎和Edge的Chakra引擎，由于代码的主要目的是提供动态页面，浏览器通过全局对象提供了一个API，使js引擎可以与之交互并改变页面内容。

js代码的不同类型：
- 函数代码：包含在函数中的代码
- 全局代码：位于函数之外的代码

全局代码由js引擎以一种直接的方式自动执行，若想执行函数代码，必须被其他代码调用。可以是全局代码，其他函数，浏览器的调用

在页面构建阶段执行js代码：
当浏览器在页面构建阶段遇到了脚本节点，会停止HTML到DOM的构建，开始执行js代码，也就是执行包含在脚本元素的全局JS代码

一般来说，js代码能够在任何程度上修改DOM结构，它能创建新的节点和移除现有节点，但它依然不能做某些事情，例如选择和修改还没被创建的节点。

一旦js引擎执行到了脚本元素js代码的最后一行，浏览器就推出了js执行模式，并继续余下的HTML构建为DOM节点。

所有在某个js代码执行期间用户创建的全局变量都能正常的被其他脚本元素中的js代码所访问到，其原因是全局window对象会存在于整个页面的生存期之间，在它上面存储着所有的js变量，只要还有没处理完的HTML元素和没执行完的js代码。

## 2.3 事件处理

客户端web应用是一种GUI应用，也就是说这种应用汇对不同类型的事件做响应，如鼠标移动，单击和键盘按压，因此在页面构建阶段执行的js代码，这类监听器会在事件发生时，由浏览器调用执行。


### 2.3.1 事件处理器

浏览器执行环境核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。

所有已生成的事件都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。

由于一次只能处理一个事件，所以我们必须格外注意处理所有事件的总时间，执行需要花费大量时间执行的事件处理函数会导致web应用无响应。

重点注意浏览器在这个过程中的机制，其放置事件的队列是在页面构建阶段和事件处理阶段以外的，这个过程对决定事件何时发生并将其推入事件队列很中要，这个过程不会参与事件处理线程。

事件是异步的：
对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生：
- 浏览器事件，例如当页面加载完成后或无法加载时
- 网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）
- 用户事件，例如鼠标单击，鼠标移动和键盘事件
- 计时器事件，当timeout时间到期或有触发了一次事件间隔

代码的提前建立是为了在之后的某个时间点执行，除了全局代码，页面中的大部分代码都将作为某个事件的结果执行。

### 2.3.2 注册事件处理器
事件处理器适当某个特定事件发生后我们希望执行的函数，我们必须告诉浏览器我们要处理哪个事件，这个过程叫做注册事件处理器。

在客户端web应用中，有两种方式注册事件：
- 用过把函数赋给某个特殊值
例如把一个函数赋值给window对象上的某个特定属性onload: window.onload = function(){}
- 通过使用内置addEventListener方法

### 处理事件

事件处理背后的思想是：当事件发生时，浏览器调用相应的事件处理器。一旦单击处理器执行完成，队列中不再有新的事件，事件循环就会继续循环，等待处理新到来的事件，这个循环会一致执行到用户关闭了web应用。


# 第二部分 函数
# 第三章 定义与函数
js中最关键的概念是：函数是第一类对象，函数和那些更普通的js数据类型一样，它能被变量引用，能以字面量形式声明，甚至能被作为函数参数进行传递

在需要调用某函数的位置定义该函数，能让我们编写更紧凑易懂的代码。
## 3.1 函数式的不同点到底是什么

函数及函数式概念重要的原因在于：函数是程序执行过程中的主要模块单元。

js中的对象有以下常用功能：
- 可通过字面量来创建{}
- 对象可以赋值给变量，数组项，或其他对象的属性
- 对象能够具有动态创建和分配的属性

### 3.1.1 函数是第一类对象

函数能实现以下功能：
- 通过字面量创建
- 赋值给变量，数组项或其他对象的属性
- 作为函数的参数来传递
- 作为函数的返回值
- 具有动态创建和分配的属性

js中函数式编程：把函数作为第一类对象是函数式编程的第一步，函数式编程是一种编程风格，它通过书写函数式代码来解决问题，函数式编程可让代码更容易测试，扩展和模块化。

第一类对象的特点是：它能够作为参数传入函数，对于函数而言，这项特性也表明：如果我们将某个函数作为参数传入另一个函数，传入函数会在应用程序执行的未来某个时间点执行。大家所熟知的概念是回调函数


### 3.1.2 回调函数

js重要特征之一是可以在表达式出现的任意位置创建函数，这个方法能使代码更加紧凑和易于理解，当一个函数不会再代码的多处位置被调用时，该特性可以避免用非必须的名字污染全局命名空间。

使用比较器排序：一般情况下只要我们拿到了一组数据集，所有的js数组都能用sort方法，函数式方式让我们能把函数作为一个单独的实体来创建，作为一个参数传入方法并将它作为一个参数来接受。

### 3.2 函数作为对象的乐趣
我们可以给函数添加属性，这种特性能做的事：
- 在集合中存储函数使我们轻易管理相关联的函数
- 记忆让函数能记住上次计算得到的值

### 3.2.1 存储函数
一种方法是把所有函数存入一个数组，通过循环该数组来检查函数，但这种方法性能较差

var store = {
    nextId: 1,
    cache: {},
    add:function(fn){
        if(!fn.id){
            fn.id = this.nextId++;
            this.cache[fn.id] = fn;
            return true
        }
    }
};
function ninja(){}
assert(store.add(ninja),
        "fucntion was safely added");
assert(!store.add(ninja),
        "But it was only added once");        
在这个清单中，我们创建了一个对象赋值给变量store，这个变量中存储的是唯一函数集合，这个对象有两个数据属性，其一是下一个可用的id，另一个缓存这已经保存的函数，函数通过add方法添加到缓存中。

### 3.2.2 自记忆函数
记忆化是一种构建函数的处理过程，鞥能够记住上次计算结果，在这个过程里，当函数计算得到结果时就将该结果暗战函数存储起来，采用这种方式时，如果另外一个调用也使用相同的参数，我们则可以直接返回上次储存的结果而不是重新计算一遍。可以显著提高性能

这个方法有两个优点：
- 由于函数调用时会寻找之前调用所得到的值，所以用户最终会乐于看到所收获的性能收益
- 几乎是无缝的发生在后台，最终用户和页面坐着都不需要执行任何特殊请求，也不需要做任何额外初始化，就能顺利进行工作

缺点：
- 任何类型的缓存都必然会为性能牺牲内存
- 纯粹注意着认为缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好
- 对于这类问题很难做负载测试或估计算法复杂度，因为结果依赖于函数之前的输入

### 3.3 函数定义
函数声明必须具有函数名是因为他们是独立语句，一个函数的基本要求是它应该能被调用，所以让必须具有一种被引用方式，于是唯一的方式就是通过它的名字。

函数表达式时其他js表达式的一部分，所以我们具有调用他们的代替方案，例如如果一个函数表达式被赋值给了变量，我们可以用该变量来调用函数。如果它是另外一个函数的参数，可以在该函数中通过相应的参数名来调用它

立即函数：
标准函数调用：

    functionname();  //一个能够计算得到函数的表达式，本例中是一个标识符
    (function(){}); //一个能够计算得到函数的表达式，本例中是一个函数表达式


加括号的函数表达式：为了避免错误，函数表达式要放在括号内，为js解析器指明它正在处理一个函数表达式而不是语句。

### 3.3.2 箭头函数

箭头函数的定义以一串可选参数名列表开头，参数名以逗号分隔，如果没有参数或者多余一个参数时，参数列表就必须包裹在括号内，只有一个参数时，括号就不是必须的，参数列表之后必须跟着一个胖箭头符号。

函数的返回值即为此表达式的返回值。

如果没有return语句，返回值为undefined

形参和实参：
- 形参是我们定义函数时所列举的变量
- 实参是我们调用函数时所传递给函数的值

### 3.4.2 默认参数

函数调用时，若没传入参数，默认参数可以给函数提供缺省的参数值

# 第四章 函数进阶：理解函数的引用

## 4.1 使用隐式函数参数
arguments参数时是传递给函数的所有参数的集合，无论是否有明确定义对应的形参，通过他我们都可以访问到函数的所有参数，借此可以实现原生js并不支持的函数重载特性，而且可以实现接受参数数量可变的可变函数。

避免把arguments参数当做数组，虽然它有length属性，而且可以通过数组下标的方式访问到每一个元素，但在arguments对象上使用数组的方法会报错，arguments是一个类数组的结构。

注：剩余参数时真正的array实例，也就是说你可以在它上面直接使用所有的数组方法。

避免使用别名：
将arguments对象作为函数参数的别名使用时会影响代码的可读性，在js提供的严格模式中无法使用它。

    "use strict";
    function infiltrate(person){
        assert(person === 'grandener');
        assert(arguments[0] === 'gardener')
        //person参数和arguments的第一个值开始是相同的
        arguments[0] = 'ninja';//第一个参数值被改变了
        assert(person === 'gardener')
        //person的值没有改变
        infiltrate("gradener");
    }

这一次arguemnts独享将不再作为参数的别名，如果想通过arguemnts[0]='ninja'改变第一个参数的值，这将不会同时改变person参数

### 4.1.2 this参数：函数上下文

当调用函数时，除了显式提供的参数外，this参数也会默认的传递给函数，this参数是面向js编程的一个重要组成部分，代表函数调用的相关联的对象。

函数上下文是来自面向对象语言的一个概念，在这些语言中，this通常指向定义当前方法的类的实例。

this参数的指向不仅是由定义函数的方式和位置决定的，同时还严重受到函数调用方式的影响。

## 4.2 函数调用

函数的调用方式对函数内代码的执行有很大的影响，主要体现在this参数以及函数上下文是如何建立的。

可通过4种方式调用一个函数：
- 作为一个函数 huahua()  直接被调用
- 作为一个方法  name.huahua() 关联在一个对象上，实现面向对象编程
- 作为一个构造函数 new huahau() 实例化一个新的对象
- 通过函数的apply或者call方法  huahau.apply(ninja)或者huahau.call(ninja)

## 4.1.2 作为函数被直接调用

如果一个函数没有作为方法，构造函数或者apply/call调用的话，我们就称之为作为函数被直接调用

## 4.2.2 作为方法被调用

当一个函数被赋值给一个对象的属性，并且通过对象属性引用的方式调用函数时，函数会作为对象的方法被调用。

当函数作为某个对象的方法被调用时，该对象会成为函数的上下文对象，并且在函数内部可以通过参数访问到。

当直接通过函数名调用时，因为是在非严格模式下执行，因此预期的函数上下文结果应当是全局上下文。



