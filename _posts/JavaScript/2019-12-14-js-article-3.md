---
layout: post
date: 2019-12-15
title: 忍者秘籍 读书笔记 -3
tags: [JavaScript]
---

哎，今天做音乐播放器，状况百出，但是也让我有点明白了编程是很需要耐心的，如果没有耐心去找问题，就会像我一样气的半死。哎，不说了，更新一下笔记吧~

---

# 第五章 精通函数：闭包和作用域

闭包是js的显著特征，如果没有闭包，事件处理和动画等包含回调函数的任务，它们的实现将变得复杂得多，如果没有闭包，将完全不可能实现私有变量。闭包是纯函数式编程语言的特性之一。闭包带来的问题是js的作用域是如何工作的。

## 5.1 理解闭包

闭包允许函数访问并操作函数外部的变量，只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数
var outerValue = "ninja";
function outerFunction(){
    console.log(outerValue === "ninja")
}
outerFunction();

其实我之前一直认为从内部return出去的那种才是闭包，原来只要是内部能够访问外部内容的也是闭包

闭包创建了被定义时的作用域内的变量和函数的安全气泡，因此函数获得了执行时所需的内容。储存和引用这些信息会直接影响性能，每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息。使用的信息都会储存在内存中，直到js引擎确保这些信息不再使用（可以安全的进行垃圾回收）或页面卸载时，才会清理这些信息。


## 5.2 使用闭包

### 5.2.1 封装私有变量

这个其实之前的笔记上有，但是我觉得这块解释的挺好的，所以重新打一遍这个。

function Ninja(){
    var feint = 0;
    this.getFeints = function(){
        return feints;
    };
    this.feint = function(){
        feints++
    };
}
var ninja1 = new Ninja();
ninja1.feint();
console.log(ninja1.feints === undefined);
console.log(ninja1.getFeints() === 1);
var ninja2 = new Ninja();
console.log(ninja2.getFeints() === 0);

通过函数上使用关键字new时，就会创建一个新的对象实例，此时调用构造函数，将新的对象作为它的上下文。

我们可通过闭包内部方法获取私有变量的值，但是不能直接访问私有变量，这有效的阻止了读取私有变量不可控的修改。

通过使用闭包，可以通过方法对ninja的状态进行维护，而不允许用户直接访问，这是因为闭包内部的变量可以通过闭包内的方法访问，构造器外部的代码则不能访问闭包内部的变量。

### 5.2.2 回调函数

回调函数指的是需要在将来不确定的某一时刻异步调用的函数，在这种回调函数中，我们经常需要频繁的访问外部的数据。

<div id="box1">first box</div>
<script>
function animationIt(elementId){
var elem = document.getElementById(ElementId)
var tick = {};
var timer = setInterval(function(){
    if(tick<100){
        elem.style.left = elem.style.top = tick + "px";
        tick++
    }
    else{
        cleanInterval(timer);
        console.log(tick === 1000);
        console.log(elem);
        console.log(timer)
    }
},10)
}
animationIt("box1");
</script>


### 5.3 通过执行上下文来跟踪代码

两种类型的代码意味着有两种类型的执行上下文：全局执行上下文和函数执行上下文。全局执行上下文只有一个，当js程序开始执行时，就创建了全局上下文，而函数执行上下文是在每次调用函数时，就会创建一个新的。

当调用函数可通过关键字访问函数上下文，函数执行上下文，虽然也称为上下文，但是完全是不一样的概念，执行上下文是内部的js概念，js引擎使用执行上下文来跟踪函数执行。

由于js的单线程执行模型：在某个特定的时刻只能执行特定的代码，一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回调发生调用的执行上下文当中，所以需要跟踪执行上下文——正在执行的上下文和正在等待的上下文，最简单的跟踪方法是使用执行上下文栈（调用栈：先进后出）

function skulk(ninja){
    report(ninja + "skulking")
}
function report(message){
    console.log(message)
}
skulk("huahua")


程序开始执行的作用域是调用栈中的全局执行作用域
函数skulk被调用后，新的函数作用域入栈，全局执行作用域暂停
report函数调用后，其作用域入栈，skulk作用域暂停
report函数执行完成后，其函数作用于出栈，skulk执行作用域恢复执行
skulk函数执行完成后，其执行作用域出栈，全局执行作用域恢复执行

注：执行上下文除了可以跟踪应用程序的执行位置之外，对于标识符也是至关重要，在静态环境中通过执行上下文可以准确定位标识符实际指向的变量


## 5.4 使用词法作用域跟踪变量的作用域

词法环境是js引擎内部用来跟踪标识符与特定变量之间的映射关系。
var ninja = "huahua";
console.log(ninja);
当执行console.log时，会进行词法环境的查询

### 5.4.1 代码嵌套

词法环境主要来自代码嵌套

### 5.4.2 代码嵌套与词法环境

除了跟踪局部变量，函数声明，函数的参数和词法环境外，还有必要跟踪外部词法环境，因为我们需要访问外部代码结构中的变量，如果在当前环境中无法找到某一标识符，就会对外部环境进行查找。

无论何时创建函数，都会创建一个新的执行环境，被推入执行上下文栈，都会创建一个与之相关联的词法环境，并存储在[[Enviornment]]的内部属性上（无法直接访问或操作）

### 5.3 理解js的变量类型
按可变性可分为：
- const
- var,let
按词法环境的关系可分为：
- var 
- const,let

const的不可变性是指：只能在声明时被初始化依稀，之后再也不允许将全新的值赋给const变量。
const变量常用于两种目的：
- 不需要重新赋值的特殊变量
- 指向一个固定的值

举个例子来理解一下吧：

const name1 = "huahua";
const name1 = "leung"; //肯定报错

const name2 = [];
name2.push(2);//不会报错，添加上去了


也就是说如果指向的值是不变的，就符合上述的不再重新赋值，而不是说对象或者数组里的内容不能修改。

### 5.5.2 定义变量的关键字和词法环境

使用var：定义的变量实际上总是在距离最近的函数内或全局词法环境中注册，不关注块级作用域。
使用let和const：直接在最近的词法环境中定义变量，我们可以使用其定义块级别，函数级别，全局级别的变量。

### 5.5.3 在词法环境中注册标识符

注册标识符的过程：
一旦创建了新的词法环境，就会执行第一阶段，在第一阶段，没有执行代码，但是js会访问并注册在当前词法环境中所声明的变量和函数，js在第一阶段完成之后开始执行第二阶段，具体取决于变量的类型以及环境类型

具体处理：
- 如果是创建一个函数环境，那么创建形参及函数参数的默认值
- 如果是创建全局或函数环境，就扫描当前代码进行函数声明，但是不会执行函数表达式或箭头函数
- 扫描当前代码进行变量声明，在函数或全局环境中，查找所有当前函数以及其他函数之外通过var声明的变量，并查找所有通过let和const定义的变量。

-----
今天累了，暂时更新到这吧，希望大家有所收获，冲鸭~