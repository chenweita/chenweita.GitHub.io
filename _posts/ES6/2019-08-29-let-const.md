---
layout: post
title: let,const和var
date: 2019-08-29
tags: [ES6]
---

今天二更了，上数电课学ES6，来分享一下。

 #   var和const,let的区别

##  块级声明

首先来了解一个概念，块级声明，是用于指定块作用域之外无法访问的变量。

块级作用域（词法作用域）存在于

- 函数内部
- 块中（{}之间的区域）

## const和let：都是块级标识符

### let声明：

1.与var相似，但声明不会被提升，会把变量限制在当前代码块中，通常将let放在封闭代码块的顶部，一边整个代码块都可访问

2.禁止重声明：假设作用域中已存在某个标识符，此时用let声明它就会报错
但如果当前作用域嵌于另一作用域，可以在内嵌的作用域里用let声明变量

### const声明：

1.声明的是常量，其值一旦设下后不可更改。因此，每个通过const声明的常量必须进行初始化

2.声明时必须赋值

3.无论在严格模式下还是非严格模式下，都不可以为const定义的常量再赋值

4.const声明不允许修改绑定，但允许修改值! (这个我在js忍者秘籍的读书笔记里有介绍，定义原始值和对象的不同)

### 循环中的块级作用域：

循环中的函数：

        var func = [];
        for(var i = 0 ;i < 10;i++){
            func.push(function(){
                console.log(i);
            });
        }
        funcs.forEach(function(func)){
            func();
        }

这个的结果是什么呢？你可能想的是0~9，但实际上，它的答案是10个10，这是因为循环里的每个变量都共享着变量i，循环内部创建的函数保留了相对相同变量的引用。

用立即调用函数表达式（IIFE），以生成计数器变量的副本。

        var func = [];
        for(var i = 0;i < 10;i++){
            func.push((function(value){
                return function(){
                    cinsole.log(value);
                }
            }(i)));
        }
        funcs.forEach(function(func){
            func();
        }) //0~9

在ES6中let和const提供的块级绑定能解决这个问题吗？
循环中的let声明：

        var func = [];
        for(let i = 0;i < 10; i++){
            funcs.push(function(){
                console.log(i);
            });
        }
        funcs.forEach(function(func){
            func();
        })
        //0~9

对于for-in和for-of来说也是一样的。

将变量的声明换成const？
上面我们说过，无论在严格模式下还是非严格模式下，都不可以为const定义的常量再赋值，也就是说，一旦在循环中，i的值发生了改变，他就会报错。所以用const是不可行的。

对于for-in和for-of跟let也是一样的。因为每次迭代不会修改已有的绑定，而是会创建一个新的绑定。

### let和const的使用：
默认使用const，只有在确实需要改变变量的时候使用let，因为大部分变量值在初始化后就不会改变，而意料外的变量值得改变是很多bug的源头

### let和const的区别总结：
1.let和const都禁止重声明，但let声明的变量值可以改变，而const不可以。

2.const声明的常量在循环中一旦改变就会报错

3.如果当前作用域嵌于另一作用域，可以在内嵌的作用域里用let声明变量，但const声明的是常量，其值一旦设下后不可更改。

4.用const声明时必须要赋值。

## let，const与var的区别

1.在声明变量时，let声明和const声明的变量不会被提升，如果是块级作用域里声明，在块级作用域外部是访问不到的。

2.var声明的变量可以重声明，但const和let不可以。

3.let和const在全局作用域的行为不同于var，当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象的属性，很可能无意中覆盖一个已经存在的全局变量
挡在全局作用域中使用let和const会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性，也就是说，不会覆盖全局变量，只会遮蔽它

